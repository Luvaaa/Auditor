# Security patterns for cryptographic and authentication vulnerabilities
patterns:
  - name: "insecure-random-for-security"
    description: "Math.random() used for security-sensitive values like tokens or keys"
    severity: "critical"
    confidence: 0.90
    # Detects Math.random() near security keywords (within 3 lines or same statement)
    # This catches patterns like: const token = Math.random().toString(36)
    regex: '(?i)(?:Math\.random|Math\.floor\s*\(\s*Math\.random|Math\.round\s*\(\s*Math\.random)(?:(?![\r\n]){0,200}(?:token|password|secret|key|auth|session|id|uuid|guid|nonce|salt|pin|otp|code|hash)|\s*\(\s*\)[^;\r\n]*(?:token|password|secret|key|auth|session|id|uuid|guid|nonce|salt|pin|otp|code|hash))'
    languages: ["javascript", "typescript"]
    files: ["*.js", "*.ts", "*.jsx", "*.tsx"]
    examples:
      - "const sessionToken = Math.random().toString(36).substring(7)"
      - "const apiKey = 'key_' + Math.random()"
      - "const resetToken = Math.floor(Math.random() * 1000000)"
      - "user.password_reset_code = Math.random().toString()"
    counter_examples:
      - "const randomIndex = Math.floor(Math.random() * array.length)"
      - "const sessionToken = crypto.randomBytes(32).toString('hex')"
      - "const delay = Math.random() * 1000"
  
  - name: "insecure-random-python"
    description: "Using random module instead of secrets for security-sensitive values"
    severity: "critical"
    confidence: 0.85
    # Detects Python's random module used for security purposes
    regex: '(?i)(?:random\.(?:random|randint|choice|randbytes|randrange|getrandbits)\s*\([^)]*\))(?:(?![\r\n]){0,200}(?:token|password|secret|key|auth|session|salt|nonce|pin|otp|code))'
    languages: ["python"]
    files: ["*.py"]
    examples:
      - "token = str(random.randint(100000, 999999))"
      - "session_id = random.random()"
      - "password_salt = random.randbytes(16)"
    counter_examples:
      - "token = secrets.token_hex(16)"
      - "index = random.randint(0, len(items)-1)"
  
  - name: "predictable-token-generation"
    description: "Predictable token generation using timestamp or sequential values"
    severity: "high"
    confidence: 0.75
    # Detects tokens generated from timestamps or incremental values
    regex: '(?i)(?:token|session|auth|key|secret|id)\s*[=:]\s*(?:Date\.now\(\)|Date\.getTime\(\)|new\s+Date\(\)\.getTime|timestamp|\+\+|counter\+\+|\w+\+\+)'
    languages: ["javascript", "typescript", "python", "java"]
    files: ["*.js", "*.ts", "*.py", "*.java", "*.jsx", "*.tsx"]
    examples:
      - "const token = Date.now().toString()"
      - "session_id = timestamp"
      - "auth_token = counter++"
    counter_examples:
      - "const token = crypto.randomUUID()"
      - "last_updated = Date.now()"
  
  - name: "weak-crypto-algorithm"
    description: "Using weak or deprecated cryptographic algorithms"
    severity: "high"
    confidence: 0.80
    # Detects MD5, SHA1, DES, RC4 usage for crypto (not file hashing)
    # Excludes: file_hash, content_hash, cache_key, etag, checksum contexts
    regex: '(?i)(?<!file_)(?<!content_)(?<!cache_)(?<!etag)(?<!check)(?:\bmd5\b|\bsha1\b|\bdes\b|\brc4\b|createHash\s*\(\s*["''](?:md5|sha1)["'']|CryptoJS\.(?:MD5|SHA1|DES|RC4))(?!.*(?:file|cache|content|etag|checksum))'
    languages: ["*"]
    files: ["*.js", "*.ts", "*.py", "*.java", "*.go", "*.rb", "*.jsx", "*.tsx"]
    examples:
      - "crypto.createHash('md5')"
      - "hashlib.md5()"
      - "CryptoJS.SHA1(password)"
    counter_examples:
      - "crypto.createHash('sha256')"
      - "hashlib.sha256()"
  
  - name: "missing-authentication-decorator"
    description: "Route/endpoint without authentication decorator or middleware"
    severity: "high"
    confidence: 0.70
    # Detects routes without common auth decorators/middleware
    # Looks for route definitions without auth keywords in the same statement or preceding line
    regex: '(?i)(?:@app\.route|@router\.(?:get|post|put|delete|patch)|app\.(?:get|post|put|delete|patch)|router\.(?:get|post|put|delete|patch))\s*\([^)]*["'']\/(?:api|admin|user|account|profile|settings|dashboard|private)[^)]*\)(?:(?!login_required|require_auth|authenticate|isAuthenticated|requireAuth|passport|jwt|protect|secured|auth)[\s\S]){0,200}(?:def\s+\w+|async\s+def\s+\w+|function|\(|\=\>)'
    languages: ["python", "javascript", "typescript"]
    files: ["*.py", "*.js", "*.ts", "*.jsx", "*.tsx"]
    examples:
      - |
        @app.route('/api/users')
        def get_users():
      - "router.post('/admin/settings', (req, res) => {"
    counter_examples:
      - |
        @app.route('/api/users')
        @login_required
        def get_users():
      - "router.post('/admin/settings', authenticate, (req, res) => {"
  
  # WebSocket Security Patterns
  - name: "websocket-no-auth-handshake"
    description: "WebSocket server or connection handler without authentication verification"
    severity: "critical"
    confidence: 0.85
    # Detects WebSocket server setup or connection handlers without auth checks
    # Looks for new WebSocket.Server, io.on('connection'), ws.on('connection') etc without auth keywords nearby
    regex: '(?i)(?:new\s+(?:WebSocket\.Server|ws\.Server|Server)|(?:wss?|io|socket)\.on\s*\(\s*["\''`]connection["\''`])(?:(?!auth|verify|check|token|session|jwt|passport|authenticate|isAuthenticated|requireAuth|authorization)[\s\S]){0,300}(?:function|\(|=>|async)'
    languages: ["javascript", "typescript"]
    files: ["*.js", "*.ts", "*.jsx", "*.tsx"]
    examples:
      - |
        const wss = new WebSocket.Server({ port: 8080 });
        wss.on('connection', function(ws) {
      - |
        io.on('connection', (socket) => {
          console.log('user connected');
      - "const server = new ws.Server({ port: 3000 });"
    counter_examples:
      - |
        wss.on('connection', async (ws, req) => {
          const token = await verifyToken(req.headers.authorization);
      - |
        io.use(authenticate).on('connection', (socket) => {
  
  - name: "websocket-no-message-validation"
    description: "WebSocket message handler using data directly without validation"
    severity: "high"
    confidence: 0.80
    # Detects message handlers that use received data directly in sensitive operations
    # Looks for on('message') followed by database operations, eval, or direct object access without validation
    regex: '(?i)(?:ws|socket)\.on\s*\(\s*["\''`](?:message|data)["\''`]\s*,\s*(?:async\s+)?(?:function\s*)?(?:\([^)]*\)|[a-zA-Z_]\w*)\s*(?:=>|\{)[^}]*(?:(?:query|exec|eval|JSON\.parse|database|db\.|find|update|insert|delete|save)\s*\((?:(?!validate|sanitize|check|verify|escape|clean|safe|schema)[\s\S])*?(?:message|data|msg|payload)|(?:message|data|msg|payload)(?:\[|\.))'
    languages: ["javascript", "typescript"]
    files: ["*.js", "*.ts", "*.jsx", "*.tsx"]
    examples:
      - |
        socket.on('message', (data) => {
          db.query('SELECT * FROM users WHERE id = ' + data.userId);
      - |
        ws.on('message', async (msg) => {
          const result = await database.find({ id: msg.id });
      - |
        socket.on('data', (payload) => {
          eval(payload.command);
    counter_examples:
      - |
        socket.on('message', (data) => {
          const validated = messageSchema.validate(data);
          if (validated.error) return;
      - |
        ws.on('message', (msg) => {
          const sanitized = sanitizeInput(msg);
  
  - name: "websocket-no-rate-limiting"
    description: "WebSocket message handler without rate limiting protection"
    severity: "high"
    confidence: 0.75
    # Detects message handlers without rate limiting logic
    # Looks for on('message') handlers without rate limit keywords in surrounding context
    regex: '(?i)(?:ws|socket)\.on\s*\(\s*["\''`](?:message|data)["\''`](?:(?!rate|limit|throttle|quota|flood|spam|cooldown|delay|bucket|window)[\s\S]){0,500}(?:\}|$)'
    languages: ["javascript", "typescript"]
    files: ["*.js", "*.ts", "*.jsx", "*.tsx"]
    examples:
      - |
        socket.on('message', (data) => {
          processMessage(data);
        });
      - |
        ws.on('message', async function(msg) {
          await handleRequest(msg);
        });
    counter_examples:
      - |
        socket.on('message', rateLimiter.middleware(), (data) => {
      - |
        ws.on('message', (msg) => {
          if (!checkRateLimit(ws.id)) return;
  
  - name: "websocket-broadcast-sensitive-data"
    description: "WebSocket broadcasting potentially sensitive data"
    severity: "critical"
    confidence: 0.70
    # Detects broadcast/emit to all clients with sensitive data
    # Looks for broadcast patterns with sensitive variable names
    regex: '(?i)(?:broadcast|emit|send|clients\.forEach|wss\.clients\.forEach|io\.emit|io\.sockets\.emit|socket\.broadcast)(?:(?!public|status|notification|update)[\s\S]){0,200}(?:password|secret|token|key|auth|session|email|ssn|credit|private|personal|sensitive|confidential|user(?:name)?["\''`]?\s*:|phone|address)'
    languages: ["javascript", "typescript"]
    files: ["*.js", "*.ts", "*.jsx", "*.tsx"]
    examples:
      - |
        io.emit('update', { username: user.email, session: sessionToken });
      - |
        wss.clients.forEach(client => {
          client.send(JSON.stringify({ password: user.password }));
      - |
        socket.broadcast.emit('user-data', { email: email, token: token });
    counter_examples:
      - |
        io.emit('notification', { message: 'User logged in', timestamp: Date.now() });
      - |
        broadcast({ type: 'status', online: true });